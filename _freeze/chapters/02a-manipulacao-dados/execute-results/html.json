{
  "hash": "d5108f27c20381e03447c411386aa878",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Aprendendo a manipular dados\"\n\n\ndate: 2026/02/03\ndate-format: long\n---\n\nDentro do `R`, existem inúmeras formas de se importar um conjunto de dados. Os dados podem ter os mais diversos formatos (extensões): \n\n* `csv`, _comma separated values_;\n* `xlsx`, formato do Excel (ao baixar a planilha);\n* `rds`^[É a forma mais recomendada, ao meu ver, de salvar objetos dentro do `R`. Um diferencial do `.rds` é que ele mantém a estrutura do objeto: ou seja, os atributos permanecem os mesmos.], formato nativo do `R`;\n* `parquet`;\n* muito mais! \n\n## Importando os pacotes no `R`\n\nComo vimos, a primeira coisa a se fazer dentro de um script no `R` é fazer a importação dos pacotes (ou bibliotecas). \n\n:::callout-note\nUm pacote é uma \"caixa de ferramentas\" extra que você instala no `R` para ganhar novas funcionalidades. Ele reúne códigos, dados e documentação em um único lugar. O termo biblioteca (library) refere-se ao local (a pasta no seu computador) onde esses pacotes ficam guardados.\n:::\n\nGeralmente, precisamos, primeiramente, instalar um pacote com a função `install.packages` e então \"carregá-lo\" para nosso ambiente, com a função `library`. Carregar um pacote significa, basicamente, dizer ao `R` que queremos utilizar um conjunto de ferramentas na nossa sessão. Dito isso: \n\n1. Sempre instala-se um pacote novo. Este processo só é feito uma vez, ou seja, utiliza-se a função `install.packages` apenas quando ainda não possuímos o pacote em nossa máquina. \n2. Após a primeira instalação, só é necessário instalar um pacote novamente caso ele tenha sido atualizado (lembra que a comunidade é ativa?). Caso não seja o caso, só é necessário \"carregar\" nosso pacote para a sessão. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n:::\n\n\nVocê pode ter notado que não utilizei as aspas (\"\") com a função `library`. Isso é opcional, você pode ou não utilizá-las. \n\n:::callout-tip \n## Dica 1\nO pacote `pacman` permite que você faça, ao mesmo tempo, a instalação e o carregamento do pacote, com a função `p_load`. Ao invés de fazer, por exemplo: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n:::\n\n\nvocê pode fazer apenas: \n\n\n::: {.cell}\n\n```{.r .cell-code}\np_load(tidyverse)\n```\n:::\n\n\nIsso é particularmente útil quando você precisa importar muitos pacotes!\n:::\n\nCaso você se esqueça de importar algum pacote, não se preocupe! É possível utilizar uma função de um pacote específico (desde que você tenha ele baixado no seu computador) sem precisar utilizar o `library(nome_do_pacote)` no começo do seu script. Ao especificar o nome do pacote e utilizar `::`, como demonstrado na @fig-dica-doispontos, é possível acessar a função desejada:\n\n![Usando uma função sem carregar o pacote](../images/dica_pacote_doispontos.png){#fig-dica-doispontos width=80% fig-align=\"center\"}\n\nAgora, basta carregamos os pacaotes de interesse\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(\n              tidyverse, # pacotão com vários pacotes core \n              rio,       # pacote que facilita a leitura de qualquer formato\n              readxl,    # pacote para ler no formato .xlsx\n              janitor    # pacote para limpeza de dados\n               )\n```\n:::\n\n\n\n# Ambientação e importação de pacotes\n\n\nFeito isso, precisamos importar o conjunto de dados a serem trabalhados no encontro de hoje. Inicialmente, vamos trabalhar com um banco de dados de personagens de `starwars`. Esse banco está \"embutido\" no pacote `dplyr`. São bases de dados para fins didáticos! \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados <- dplyr::starwars\n```\n:::\n\n\n# Estatística descritiva e manipulação de dados\n\n## Utilizando o R Base\n\nFeita a importação dos dados, podemos visualizá-los com a função `head()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dados)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n1 Luke Sky…    172    77 blond      fair       blue            19   male  mascu…\n2 C-3PO        167    75 <NA>       gold       yellow         112   none  mascu…\n3 R2-D2         96    32 <NA>       white, bl… red             33   none  mascu…\n4 Darth Va…    202   136 none       white      yellow          41.9 male  mascu…\n5 Leia Org…    150    49 brown      light      brown           19   fema… femin…\n6 Owen Lars    178   120 brown, gr… light      blue            52   male  mascu…\n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n\n\n:::\n:::\n\n\nÉ possível, também, especificar quantas linhas queremos ver. Por exemplo, as 3 primeiras linhas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(dados, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n1 Luke Sky…    172    77 blond      fair       blue              19 male  mascu…\n2 C-3PO        167    75 <NA>       gold       yellow           112 none  mascu…\n3 R2-D2         96    32 <NA>       white, bl… red               33 none  mascu…\n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n\n\n:::\n:::\n\n\nSe eu quiser saber quais são as últimas linhas do meu banco de dados, posso usar a função `tail()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(dados)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n1 Tion Med…    206    80 none       grey       black             NA male  mascu…\n2 Finn          NA    NA black      dark       dark              NA male  mascu…\n3 Rey           NA    NA brown      light      hazel             NA fema… femin…\n4 Poe Dame…     NA    NA brown      light      brown             NA male  mascu…\n5 BB8           NA    NA none       none       black             NA none  mascu…\n6 Captain …     NA    NA none       none       unknown           NA fema… femin…\n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n\n\n:::\n:::\n\n\nPara acessar alguma coluna dentro do meu objeto `dados`, basta usar o `$`. Com o `$`, posso usar a função `mean()` para saber a média de alguma variável de interesse:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(dados$height)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nRecebemos uma resposta estranha: `NA`. Existem 03 classes especiais de objetos:: `NA`, `NULL` e `NaN`. `NULL` significa que eu estou tentando acessar um elemento que não existe, logo, ele é *nulo*. `NaN` significa \"Not a Number\", que é autoexplicativo^[Se eu tento dividir 0 por 0, por exemplo, o resultado é `NaN`.]. Já o `NA` significa \"Not Available\", ou seja, não está disponível. O `NA` geralmente acontece quando fazemos medidas descritivas, como a média, e o nosso conjunto de dados tem algum valor faltante. Para contornar esse problema, usamos a seguinte opção dentro da função `mean`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(dados$height, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 174.6049\n```\n\n\n:::\n:::\n\n\n`na.rm` significa, basicamente, \"na remove\". Ou seja, remover os valores ausentes. Assim, consigo ver a média da altura dos personagens de Star Wars. \n\nTambém posso analisar o **desvio padrão** da altura dos personagens. O desvio padrão é uma medida de dispersão que mostra, em média, quanto os valores se distanciam da média de uma variável. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsd(dados$height, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 34.77416\n```\n\n\n:::\n:::\n\n\n## Operadores lógicos \n\n\n| Operador | Operação                          |\n|----------|:----------------------------------|\n| `!`      | Negação (não)                     |\n| `&`      | E (avalia elemento a elemento)    |\n| `|`      | Ou (avalia elemento a elemento)   |\n| `<`      | Menor                             |\n| `<=`     | Menor ou igual                    |\n| `>`      | Maior                             |\n| `>=`     | Maior ou igual                    |\n| `!=`     | Diferente                         |\n| `&&`     | E (avalia apenas o 1º elemento)   |\n| `||`     | Ou (avalia apenas o 1º elemento)  |\n\n: Operadores lógicos no `R`\n\nOperadores lógicos no R são símbolos usados para fazer comparações e testar condições, retornando valores TRUE ou FALSE. É muito comum utilizarmos eles em filtros. Às vezes, queremos filtrar resultados dado uma condição específica. Veremos isso mais à frente. \n\n## Encadeando funções com o operador pipe ` |>  `\n\nRené Magritte tem uma pintura icônica, que inspirou um pacote no `R`. O pacote é chamado de `{magrittr}` e ele basicamente nos apresenta um conceito fantástico: o operador pipe. Basicamente, o pipe pega o lado esquerdo do seu código e alimenta o lado direito, encadeando as funções que você for utilizar. \n\n![La trahison des images](https://modern-rstats.eu/assets/pas_une_pipe.png)\n\nEsse conceito ficará mais claro adiante, mas é importante saber da existência dele. Sempre que virmos um `|>` no nosso código, leremos ele como um \"e então\". Pode ser que o pipe apareça para você como `%>%`, mas isso não faz muita diferença agora. O atalho para o operador pipe é `CTRL + SHIFT + M`. \n\n## Conhecendo o pacote `{dplyr}`\n\nO `{dplyr}` é um dos principais pacotes do `{tidyverse}`, e é nele que passaremos a maior parte do tempo. Isso porque, quando trabalhamos com dados, a maior parte da energia que gastamos é em \"limpar\" os dados. O `{dplyr}` tem alguns \"verbos\" que são os mais utilizados. Vamos conhecê-los. \n\nSe quiser, por exemplo, verificar a **média da altura** dos personagens de Star Wars por **sexo**, podemos fazer da seguinte forma: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados |> \n  group_by(sex) |> \n  summarise(media_altura = mean(height, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  sex            media_altura\n  <chr>                 <dbl>\n1 female                 172.\n2 hermaphroditic         175 \n3 male                   179.\n4 none                   131.\n5 <NA>                   175 \n```\n\n\n:::\n:::\n\nLemos essa operação da seguinte forma: *\"pegue o objeto dados, **e então** agrupe-o por sexo, **e então** calcule a média para cada subgrupo, omitindo os valores ausentes\"*.   \n\nSem o operador `|>`, teríamos de escrever o código da seguinte forma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(group_by(dados, sex), mean(height, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  sex            `mean(height, na.rm = TRUE)`\n  <chr>                                 <dbl>\n1 female                                 172.\n2 hermaphroditic                         175 \n3 male                                   179.\n4 none                                   131.\n5 <NA>                                   175 \n```\n\n\n:::\n:::\n\n\nConcordamos que o `|>` é uma mão na roda, né?\n\nAinda, é possível **filtrar** informações de interesse primeiro. Por exemplo, se eu quero filtrar a altura de personagens cujo gênero é \"masculine\", basta inserirmos a função `filter()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados |> \n  filter(gender == \"masculine\") |> \n  group_by(sex) |> \n  summarise(media_altura = mean(height, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  sex            media_altura\n  <chr>                 <dbl>\n1 hermaphroditic         175 \n2 male                   179.\n3 none                   140 \n```\n\n\n:::\n:::\n\nLemos essa operação da seguinte forma: *\"pegue o objeto dados, **e então** filtre as ocorrências cuja variável `gender` seja igual a \"masculine\", **e então** agrupe-o por sexo, **e então** calcule a média para cada subgrupo, omitindo os valores ausentes\"*.  \n\nSe precisarmos de mais medidas para além da média da altura, podemos adicionar várias funções conforme precisarmos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabela_descritiva <- dados |> \n  group_by(sex) |> \n  summarise(media_altura = mean(height, na.rm = TRUE),\n            variancia_altura = var(height, na.rm = TRUE),\n            desvio_altura = sd(height, na.rm = TRUE),\n            n_obs = n()) # número de observações\n\ntabela_descritiva\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  sex            media_altura variancia_altura desvio_altura n_obs\n  <chr>                 <dbl>            <dbl>         <dbl> <int>\n1 female                 172.             253.          15.9    16\n2 hermaphroditic         175               NA           NA       1\n3 male                   179.            1297.          36.0    60\n4 none                   131.            2416.          49.1     6\n5 <NA>                   175              153.          12.4     4\n```\n\n\n:::\n:::\n\n\nA função `var()` me dá a variância da altura e a função `n()` me retorna o número de observações. Na nossa tabela descritiva, vimos que temos um grupo com apenas 01 indivíduo. Se quisermos, por exemplo, analisar os sexos que tem mais de um indivíduo, podemos filtrar:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntabela_descritiva2 <- tabela_descritiva |> \n  filter(n_obs > 1)\n\ntabela_descritiva2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n  sex    media_altura variancia_altura desvio_altura n_obs\n  <chr>         <dbl>            <dbl>         <dbl> <int>\n1 female         172.             253.          15.9    16\n2 male           179.            1297.          36.0    60\n3 none           131.            2416.          49.1     6\n4 <NA>           175              153.          12.4     4\n```\n\n\n:::\n:::\n\n\n### Filtrando `NAs`\n\nÉ um pouco cansativo ficar utilizando o argumento `na.rm = TRUE` o tempo todo para filtrar os NAs a cada operação. Antes de eliminarmos quaisquer valores ausentes, é preciso conhecer nosso banco de dados para tomar esta decisão. Isso porque, como alguns cientistas sociais dizem, um **não dado** também é **dado**! Muitos valores ausentes podem indicar, por exemplo, como as pessoas estão registrando (no caso, deixando de registrar) as ocorrências. Muitos `NAs` pode ser sinal de mal preenchimento de informações. \n\nVoltando para nosso conjunto de dados, vamos ver quantas linhas temos na coluna `sex` que são `NA`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados |> \n  filter(is.na(sex))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 14\n  name      height  mass hair_color skin_color eye_color birth_year sex   gender\n  <chr>      <int> <dbl> <chr>      <chr>      <chr>          <dbl> <chr> <chr> \n1 Jek Tono…    180   110 brown      fair       blue              NA <NA>  <NA>  \n2 Gregar T…    185    85 black      dark       brown             NA <NA>  <NA>  \n3 Cordé        157    NA brown      light      brown             NA <NA>  <NA>  \n4 Sly Moore    178    48 none       pale       white             NA <NA>  <NA>  \n# ℹ 5 more variables: homeworld <chr>, species <chr>, films <list>,\n#   vehicles <list>, starships <list>\n```\n\n\n:::\n:::\n\n\nSão apenas 04 linhas. Podemos ignorálas. Refazendo a análise da primeira tabela descritiva:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados |> \n  filter(!is.na(sex)) |> \n  group_by(sex) |> \n  summarise(media_altura = mean(height, na.rm = TRUE),\n            variancia_altura = var(height, na.rm = TRUE),\n            desvio_altura = sd(height, na.rm = TRUE),\n            n_obs = n()) |> \n  filter(n_obs > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  sex    media_altura variancia_altura desvio_altura n_obs\n  <chr>         <dbl>            <dbl>         <dbl> <int>\n1 female         172.             253.          15.9    16\n2 male           179.            1297.          36.0    60\n3 none           131.            2416.          49.1     6\n```\n\n\n:::\n:::\n\n\nE se quisermos adicionar outra variável ao nosso grupo?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndados |> \n  filter(!is.na(sex)) |> \n  group_by(sex, eye_color) |> \n  summarise(media_altura = mean(height, na.rm = TRUE),\n            variancia_altura = var(height, na.rm = TRUE),\n            desvio_altura = sd(height, na.rm = TRUE),\n            n_obs = n()) |> \n  filter(n_obs > 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 6\n# Groups:   sex [3]\n   sex    eye_color media_altura variancia_altura desvio_altura n_obs\n   <chr>  <chr>            <dbl>            <dbl>         <dbl> <int>\n 1 female black             196.            612.         24.7       2\n 2 female blue              167             118.         10.9       6\n 3 female brown             166.            209.         14.5       4\n 4 female hazel             178              NA          NA         2\n 5 male   black             182            1197          34.6       7\n 6 male   blue              190             429.         20.7      12\n 7 male   brown             167.           1657.         40.7      15\n 8 male   orange            181.           1306.         36.1       7\n 9 male   red               190.              0.5         0.707     2\n10 male   unknown           136            6498          80.6       2\n11 male   yellow            180.           2196.         46.9       9\n12 none   red               131            3571          59.8       3\n```\n\n\n:::\n:::\n\n\nPara essa primeira parte, está suficiente. Conhecemos as funções `filter()`, `group_by()` e `summarise()` do pacote `{dplyr}`. \n\n# Usando o dataset `Gasoline`\n\nPrimeiro, precisamos instalar o pacote `plm`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"plm\")\n```\n:::\n\n\nAgora, vamos carregar os dados que estão dentro do pacote:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(Gasoline, package = \"plm\")\n```\n:::\n\n\nEste conjunto de dados nos dá informações sobre consumo de gasolina para 18 países, entre 1960 e 1978. As variáveis são:\n\n| Variável   | Descrição                                                                 |\n|-----------|---------------------------------------------------------------------------|\n| country   | Fator com 18 níveis (países)                                              |\n| year      | Ano                                                                       |\n| lgaspcar  | Logaritmo do consumo de gasolina por carro                                |\n| lincomep  | Logaritmo da renda real per capita                                        |\n| lrpmg     | Logaritmo do preço real da gasolina                                       |\n| lcarpcap  | Logaritmo do estoque de carros per capita                                 |\n\n\nQuando carregamos este conjunto de dados, ele pertence à uma classe chamada `data.frame`. O `R` possui uma classe diferente e especial para conjunto de dados, que apresenta um melhor \"print\" no console, chamada `tibble`. Para convertemos este conjunto de dados (no formato `data.frame`) para `tibble`, executamos a seguinte operação: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline <- as_tibble(Gasoline)\n```\n:::\n\n\nAdicionalmente, quero deixar todas os países da coluna `country` com letras minúsculas. Para isso: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline <- gasoline |> \n  mutate(country = tolower(country))\n```\n:::\n\n\nE se eu quiser filtrar os dados somente para o ano de 1972? Muito simples com a função `filter()`, sem utilizar o `|>`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(gasoline, year == 1972)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 6\n   country   year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>    <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria   1972     4.13    -5.98 -0.596    -8.54\n 2 belgium   1972     3.91    -5.71 -0.311    -8.36\n 3 canada    1972     4.89    -5.44 -1.10     -7.99\n 4 denmark   1972     4.08    -5.65 -0.499    -8.33\n 5 france    1972     3.85    -5.70 -0.408    -8.22\n 6 germany   1972     3.93    -5.72 -0.718    -8.24\n 7 greece    1972     4.80    -6.35 -0.120   -10.3 \n 8 ireland   1972     4.27    -6.31 -0.424    -8.82\n 9 italy     1972     3.63    -6.21 -0.215    -8.38\n10 japan     1972     4.22    -5.93 -0.521    -9.05\n11 netherla  1972     3.92    -5.79 -0.319    -8.38\n12 norway    1972     4.08    -5.66 -0.260    -8.51\n13 spain     1972     3.89    -5.46  0.537    -9.27\n14 sweden    1972     3.98    -7.74 -2.77     -8.10\n15 switzerl  1972     4.26    -5.81 -0.940    -8.30\n16 turkey    1972     5.58    -7.08 -0.546   -12.2 \n17 u.k.      1972     3.99    -5.97 -0.528    -8.36\n18 u.s.a.    1972     4.85    -5.35 -1.33     -7.68\n```\n\n\n:::\n:::\n\n\nMas, é bom nos acostumarmos com o operador pipe, portanto: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline |> \n  filter(year == 1972)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 6\n   country   year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>    <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria   1972     4.13    -5.98 -0.596    -8.54\n 2 belgium   1972     3.91    -5.71 -0.311    -8.36\n 3 canada    1972     4.89    -5.44 -1.10     -7.99\n 4 denmark   1972     4.08    -5.65 -0.499    -8.33\n 5 france    1972     3.85    -5.70 -0.408    -8.22\n 6 germany   1972     3.93    -5.72 -0.718    -8.24\n 7 greece    1972     4.80    -6.35 -0.120   -10.3 \n 8 ireland   1972     4.27    -6.31 -0.424    -8.82\n 9 italy     1972     3.63    -6.21 -0.215    -8.38\n10 japan     1972     4.22    -5.93 -0.521    -9.05\n11 netherla  1972     3.92    -5.79 -0.319    -8.38\n12 norway    1972     4.08    -5.66 -0.260    -8.51\n13 spain     1972     3.89    -5.46  0.537    -9.27\n14 sweden    1972     3.98    -7.74 -2.77     -8.10\n15 switzerl  1972     4.26    -5.81 -0.940    -8.30\n16 turkey    1972     5.58    -7.08 -0.546   -12.2 \n17 u.k.      1972     3.99    -5.97 -0.528    -8.36\n18 u.s.a.    1972     4.85    -5.35 -1.33     -7.68\n```\n\n\n:::\n:::\n\n\nTambém é possível filtrar mais de uma condição. Para isso, podemos usar o operador `%in%`: \n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  filter(year %in% seq(1969, 1973)) # sequência de anos entre 1969 a 1973\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 90 × 6\n   country  year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1969     4.05    -6.15 -0.559    -8.79\n 2 austria  1970     4.08    -6.08 -0.597    -8.73\n 3 austria  1971     4.11    -6.04 -0.654    -8.64\n 4 austria  1972     4.13    -5.98 -0.596    -8.54\n 5 austria  1973     4.20    -5.90 -0.594    -8.49\n 6 belgium  1969     3.85    -5.86 -0.355    -8.52\n 7 belgium  1970     3.87    -5.80 -0.378    -8.45\n 8 belgium  1971     3.87    -5.76 -0.399    -8.41\n 9 belgium  1972     3.91    -5.71 -0.311    -8.36\n10 belgium  1973     3.90    -5.64 -0.373    -8.31\n# ℹ 80 more rows\n```\n\n\n:::\n:::\n\n\nOu \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  filter(year %in% 1969:1973) # sem a função seq()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 90 × 6\n   country  year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1969     4.05    -6.15 -0.559    -8.79\n 2 austria  1970     4.08    -6.08 -0.597    -8.73\n 3 austria  1971     4.11    -6.04 -0.654    -8.64\n 4 austria  1972     4.13    -5.98 -0.596    -8.54\n 5 austria  1973     4.20    -5.90 -0.594    -8.49\n 6 belgium  1969     3.85    -5.86 -0.355    -8.52\n 7 belgium  1970     3.87    -5.80 -0.378    -8.45\n 8 belgium  1971     3.87    -5.76 -0.399    -8.41\n 9 belgium  1972     3.91    -5.71 -0.311    -8.36\n10 belgium  1973     3.90    -5.64 -0.373    -8.31\n# ℹ 80 more rows\n```\n\n\n:::\n:::\n\nAinda, é possível utilizar a função auxiliadora^[Como o nome sugere, funções auxiliadores ajudam as funções principais. É importante notar que é possível usar funções dentro de funções.] `between()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  filter(between(year, 1969, 1973))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 90 × 6\n   country  year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1969     4.05    -6.15 -0.559    -8.79\n 2 austria  1970     4.08    -6.08 -0.597    -8.73\n 3 austria  1971     4.11    -6.04 -0.654    -8.64\n 4 austria  1972     4.13    -5.98 -0.596    -8.54\n 5 austria  1973     4.20    -5.90 -0.594    -8.49\n 6 belgium  1969     3.85    -5.86 -0.355    -8.52\n 7 belgium  1970     3.87    -5.80 -0.378    -8.45\n 8 belgium  1971     3.87    -5.76 -0.399    -8.41\n 9 belgium  1972     3.91    -5.71 -0.311    -8.36\n10 belgium  1973     3.90    -5.64 -0.373    -8.31\n# ℹ 80 more rows\n```\n\n\n:::\n:::\n\n\nTambém é possível selecionar anos não consecutivos: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  filter(year %in% c(1969, 1973, 1977))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 54 × 6\n   country  year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1969     4.05    -6.15 -0.559    -8.79\n 2 austria  1973     4.20    -5.90 -0.594    -8.49\n 3 austria  1977     3.93    -5.83 -0.422    -8.25\n 4 belgium  1969     3.85    -5.86 -0.355    -8.52\n 5 belgium  1973     3.90    -5.64 -0.373    -8.31\n 6 belgium  1977     3.85    -5.56 -0.432    -8.14\n 7 canada   1969     4.86    -5.56 -1.04     -8.10\n 8 canada   1973     4.90    -5.41 -1.13     -7.94\n 9 canada   1977     4.81    -5.34 -1.07     -7.77\n10 denmark  1969     4.17    -5.72 -0.407    -8.47\n# ℹ 44 more rows\n```\n\n\n:::\n:::\n\n\n## Usando a função `select()`\n\nEnquanto a função `filter()` é utilizada para manter ou descartar as linhas do nosso conjunto de dados, a função `select()` nos permite **selecionar** colunas inteiras. \n\nPara manter  colunas, podemos utilizar:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  select(country, year, lrpmg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 3\n   country  year  lrpmg\n   <chr>   <int>  <dbl>\n 1 austria  1960 -0.335\n 2 austria  1961 -0.351\n 3 austria  1962 -0.380\n 4 austria  1963 -0.414\n 5 austria  1964 -0.445\n 6 austria  1965 -0.497\n 7 austria  1966 -0.467\n 8 austria  1967 -0.506\n 9 austria  1968 -0.522\n10 austria  1969 -0.559\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nPara descartálas, utilizamos: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  select(-country, -year, -lrpmg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 3\n   lgaspcar lincomep lcarpcap\n      <dbl>    <dbl>    <dbl>\n 1     4.17    -6.47    -9.77\n 2     4.10    -6.43    -9.61\n 3     4.07    -6.41    -9.46\n 4     4.06    -6.37    -9.34\n 5     4.04    -6.32    -9.24\n 6     4.03    -6.29    -9.12\n 7     4.05    -6.25    -9.02\n 8     4.05    -6.23    -8.93\n 9     4.05    -6.21    -8.85\n10     4.05    -6.15    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nAinda, é possível renomeá-las diretamente com a função `select()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  select(country, date = year, lrpmg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 3\n   country  date  lrpmg\n   <chr>   <int>  <dbl>\n 1 austria  1960 -0.335\n 2 austria  1961 -0.351\n 3 austria  1962 -0.380\n 4 austria  1963 -0.414\n 5 austria  1964 -0.445\n 6 austria  1965 -0.497\n 7 austria  1966 -0.467\n 8 austria  1967 -0.506\n 9 austria  1968 -0.522\n10 austria  1969 -0.559\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nA função `rename()` faz exatamente a mesma coisa. Entretanto, ele não faz nenhum tipo de seleção, apenas renomea a coluna de interesse. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  rename(date = year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 6\n   country  date lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1960     4.17    -6.47 -0.335    -9.77\n 2 austria  1961     4.10    -6.43 -0.351    -9.61\n 3 austria  1962     4.07    -6.41 -0.380    -9.46\n 4 austria  1963     4.06    -6.37 -0.414    -9.34\n 5 austria  1964     4.04    -6.32 -0.445    -9.24\n 6 austria  1965     4.03    -6.29 -0.497    -9.12\n 7 austria  1966     4.05    -6.25 -0.467    -9.02\n 8 austria  1967     4.05    -6.23 -0.506    -8.93\n 9 austria  1968     4.05    -6.21 -0.522    -8.85\n10 austria  1969     4.05    -6.15 -0.559    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nÉ possível utilizar a função `select()` para reordenar as colunas. Eu quero, por exemplo, que minhas três primeiras colunas do conjunto de dados sejam `year`, `country` e `lrpmg`, nesta ordem: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  select(year, country, lrpmg, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 6\n    year country  lrpmg lgaspcar lincomep lcarpcap\n   <int> <chr>    <dbl>    <dbl>    <dbl>    <dbl>\n 1  1960 austria -0.335     4.17    -6.47    -9.77\n 2  1961 austria -0.351     4.10    -6.43    -9.61\n 3  1962 austria -0.380     4.07    -6.41    -9.46\n 4  1963 austria -0.414     4.06    -6.37    -9.34\n 5  1964 austria -0.445     4.04    -6.32    -9.24\n 6  1965 austria -0.497     4.03    -6.29    -9.12\n 7  1966 austria -0.467     4.05    -6.25    -9.02\n 8  1967 austria -0.506     4.05    -6.23    -8.93\n 9  1968 austria -0.522     4.05    -6.21    -8.85\n10  1969 austria -0.559     4.05    -6.15    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nA função `everything()` é uma função auxiliadora, como notamos. Ainda, existem outras funções, como por exemplo `starts_with` e `ends_with`. Se eu quiser, por exemplo, selecionar apenas as colunas cujo nome começam com \"l\"? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  select(starts_with(\"l\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 4\n   lgaspcar lincomep  lrpmg lcarpcap\n      <dbl>    <dbl>  <dbl>    <dbl>\n 1     4.17    -6.47 -0.335    -9.77\n 2     4.10    -6.43 -0.351    -9.61\n 3     4.07    -6.41 -0.380    -9.46\n 4     4.06    -6.37 -0.414    -9.34\n 5     4.04    -6.32 -0.445    -9.24\n 6     4.03    -6.29 -0.497    -9.12\n 7     4.05    -6.25 -0.467    -9.02\n 8     4.05    -6.23 -0.506    -8.93\n 9     4.05    -6.21 -0.522    -8.85\n10     4.05    -6.15 -0.559    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\n`ends_with` funciona de maneira similar, dá para pegar a ideia. Outra função auxiliadora interessante é a `contains()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  select(country, year, contains(\"car\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 4\n   country  year lgaspcar lcarpcap\n   <chr>   <int>    <dbl>    <dbl>\n 1 austria  1960     4.17    -9.77\n 2 austria  1961     4.10    -9.61\n 3 austria  1962     4.07    -9.46\n 4 austria  1963     4.06    -9.34\n 5 austria  1964     4.04    -9.24\n 6 austria  1965     4.03    -9.12\n 7 austria  1966     4.05    -9.02\n 8 austria  1967     4.05    -8.93\n 9 austria  1968     4.05    -8.85\n10 austria  1969     4.05    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nÉ possível encontrar uma lista de funções auxiliadoras na [documentação](https://tidyselect.r-lib.org/reference/language.html) do pacote. A documentação é uma espécie de manual, onde os desenvolvedores dos pacotes apresentam as principais funções, argumentos e exemplos de uso. Basta pesquisar por `nome do pacote + R` no Google que você acha as informações oficiais com bastante facilidade. A documentação do pacote [`{dplyr}`](https://dplyr.tidyverse.org/) é facilmente encontrada. ]\n\nOutro verbo/função similar ao `select()` é o `pull()`. Como o nome sugere, ele puxa as informações de uma coluna específica. Comparativamente: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  select(lrpmg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 1\n    lrpmg\n    <dbl>\n 1 -0.335\n 2 -0.351\n 3 -0.380\n 4 -0.414\n 5 -0.445\n 6 -0.497\n 7 -0.467\n 8 -0.506\n 9 -0.522\n10 -0.559\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  pull(lrpmg) %>%\n  head() # usando o head() porque temos muitos elementos neste conjunto de daods\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -0.3345476 -0.3513276 -0.3795177 -0.4142514 -0.4453354 -0.4970607\n```\n\n\n:::\n:::\n\n\n## Agrupando informações com `group_by()`\n\nA função `group_by()` facilita a computação de estatísticas descritivas por grupos. Agrupando os dados por país: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 6\n# Groups:   country [18]\n   country  year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1960     4.17    -6.47 -0.335    -9.77\n 2 austria  1961     4.10    -6.43 -0.351    -9.61\n 3 austria  1962     4.07    -6.41 -0.380    -9.46\n 4 austria  1963     4.06    -6.37 -0.414    -9.34\n 5 austria  1964     4.04    -6.32 -0.445    -9.24\n 6 austria  1965     4.03    -6.29 -0.497    -9.12\n 7 austria  1966     4.05    -6.25 -0.467    -9.02\n 8 austria  1967     4.05    -6.23 -0.506    -8.93\n 9 austria  1968     4.05    -6.21 -0.522    -8.85\n10 austria  1969     4.05    -6.15 -0.559    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nNão parece que mudou muita coisa, mas,  se observamos a segunda linha do output, veremos que:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## # Groups:   country [18]\n```\n:::\n\n\nIsso significa que toda análise levará estes grupos em conta. Como vimos anteriormente com o `starwars`, é possível agrupar por mais de uma variável:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 6\n# Groups:   country, year [342]\n   country  year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1960     4.17    -6.47 -0.335    -9.77\n 2 austria  1961     4.10    -6.43 -0.351    -9.61\n 3 austria  1962     4.07    -6.41 -0.380    -9.46\n 4 austria  1963     4.06    -6.37 -0.414    -9.34\n 5 austria  1964     4.04    -6.32 -0.445    -9.24\n 6 austria  1965     4.03    -6.29 -0.497    -9.12\n 7 austria  1966     4.05    -6.25 -0.467    -9.02\n 8 austria  1967     4.05    -6.23 -0.506    -8.93\n 9 austria  1968     4.05    -6.21 -0.522    -8.85\n10 austria  1969     4.05    -6.15 -0.559    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nE também é possível desagrupar, com a função `ungroup()`. Basicamente, o `group_by` \"marca\" a tabela para que os cálculos sejam feitos por grupo, e o `ungroup()` volta para que você trabalhe com a tabela como um todo. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country, year) %>%\n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 6\n   country  year lgaspcar lincomep  lrpmg lcarpcap\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>\n 1 austria  1960     4.17    -6.47 -0.335    -9.77\n 2 austria  1961     4.10    -6.43 -0.351    -9.61\n 3 austria  1962     4.07    -6.41 -0.380    -9.46\n 4 austria  1963     4.06    -6.37 -0.414    -9.34\n 5 austria  1964     4.04    -6.32 -0.445    -9.24\n 6 austria  1965     4.03    -6.29 -0.497    -9.12\n 7 austria  1966     4.05    -6.25 -0.467    -9.02\n 8 austria  1967     4.05    -6.23 -0.506    -8.93\n 9 austria  1968     4.05    -6.21 -0.522    -8.85\n10 austria  1969     4.05    -6.15 -0.559    -8.79\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\n## Resumir estatísticas com `summarise()`\n\nPassado o básico, vamos avançar. Se eu quero computar o consume médio de gasolina por cada país, para todo o período, fazemos: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country) %>%\n  summarise(mean(lgaspcar))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 2\n   country  `mean(lgaspcar)`\n   <chr>               <dbl>\n 1 austria              4.06\n 2 belgium              3.92\n 3 canada               4.86\n 4 denmark              4.19\n 5 france               3.82\n 6 germany              3.89\n 7 greece               4.88\n 8 ireland              4.23\n 9 italy                3.73\n10 japan                4.70\n11 netherla             4.08\n12 norway               4.11\n13 spain                4.06\n14 sweden               4.01\n15 switzerl             4.24\n16 turkey               5.77\n17 u.k.                 3.98\n18 u.s.a.               4.82\n```\n\n\n:::\n:::\n\n\nComo vimos com o `starwars`, é possível renomear o nome da coluna da média que apareceu anteriormente. Para isso: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country) %>%\n  summarise(mean_gaspcar = mean(lgaspcar))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 2\n   country  mean_gaspcar\n   <chr>           <dbl>\n 1 austria          4.06\n 2 belgium          3.92\n 3 canada           4.86\n 4 denmark          4.19\n 5 france           3.82\n 6 germany          3.89\n 7 greece           4.88\n 8 ireland          4.23\n 9 italy            3.73\n10 japan            4.70\n11 netherla         4.08\n12 norway           4.11\n13 spain            4.06\n14 sweden           4.01\n15 switzerl         4.24\n16 turkey           5.77\n17 u.k.             3.98\n18 u.s.a.           4.82\n```\n\n\n:::\n:::\n\n\nAlém disso, podemos filtrar as ocorrências para um país de interesse: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country) %>%\n  summarise(mean_gaspcar = mean(lgaspcar)) %>%\n  filter(country == \"france\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  country mean_gaspcar\n  <chr>          <dbl>\n1 france          3.82\n```\n\n\n:::\n:::\n\n\nCom a função `summarise()`, posso computar várias estatísticas de uma vez: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country) %>%\n  summarise(mean_gaspcar = mean(lgaspcar),\n            sd_gaspcar = sd(lgaspcar),\n            max_gaspcar = max(lgaspcar),\n            min_gaspcar = min(lgaspcar))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 18 × 5\n   country  mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar\n   <chr>           <dbl>      <dbl>       <dbl>       <dbl>\n 1 austria          4.06     0.0693        4.20        3.92\n 2 belgium          3.92     0.103         4.16        3.82\n 3 canada           4.86     0.0262        4.90        4.81\n 4 denmark          4.19     0.158         4.50        4.00\n 5 france           3.82     0.0499        3.91        3.75\n 6 germany          3.89     0.0239        3.93        3.85\n 7 greece           4.88     0.255         5.38        4.48\n 8 ireland          4.23     0.0437        4.33        4.16\n 9 italy            3.73     0.220         4.05        3.38\n10 japan            4.70     0.684         6.00        3.95\n11 netherla         4.08     0.286         4.65        3.71\n12 norway           4.11     0.123         4.44        3.96\n13 spain            4.06     0.317         4.75        3.62\n14 sweden           4.01     0.0364        4.07        3.91\n15 switzerl         4.24     0.102         4.44        4.05\n16 turkey           5.77     0.329         6.16        5.14\n17 u.k.             3.98     0.0479        4.10        3.91\n18 u.s.a.           4.82     0.0219        4.86        4.79\n```\n\n\n:::\n:::\n\n\nE se quisermos \"salvar\" essas operações, basta atribuir a um objeto^[Lembrando que o sinal de atribuição mais apropriado é o `<- `. Para fazê-lo, o atalho é `ALT -` (alt menos)]: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesc_gasoline <- gasoline %>%\n  group_by(country) %>%\n  summarise(mean_gaspcar = mean(lgaspcar),\n            sd_gaspcar = sd(lgaspcar),\n            max_gaspcar = max(lgaspcar),\n            min_gaspcar = min(lgaspcar))\n```\n:::\n\n\nQuestão: qual país tem o maior consumo médio de gasolina? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesc_gasoline %>%\n  filter(max(mean_gaspcar) == mean_gaspcar)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  country mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar\n  <chr>          <dbl>      <dbl>       <dbl>       <dbl>\n1 turkey          5.77      0.329        6.16        5.14\n```\n\n\n:::\n:::\n\n\nA função `max(mean_gaspcar)` calcula o maior valor da média de consumo de gasolina. Depois, fazemos uma comparação lógica para verificar se o valor naquela linha é igual ao valor máximo da coluna. Eu, particularmente, acho assim mais complicado de entender. Alternativametne, podemos usar: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesc_gasoline %>% \n  slice_max(mean_gaspcar) # mais direto e reto!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  country mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar\n  <chr>          <dbl>      <dbl>       <dbl>       <dbl>\n1 turkey          5.77      0.329        6.16        5.14\n```\n\n\n:::\n:::\n\n\nOu, também: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesc_gasoline %>% \n  slice(which.max(mean_gaspcar))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  country mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar\n  <chr>          <dbl>      <dbl>       <dbl>       <dbl>\n1 turkey          5.77      0.329        6.16        5.14\n```\n\n\n:::\n:::\n\n\nA Túrquia tem o maior consumo médio de gasolina. E o valor mínimo? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesc_gasoline %>% \n  slice_min(mean_gaspcar) # mais direto e reto!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n  country mean_gaspcar sd_gaspcar max_gaspcar min_gaspcar\n  <chr>          <dbl>      <dbl>       <dbl>       <dbl>\n1 italy           3.73      0.220        4.05        3.38\n```\n\n\n:::\n:::\n\n\n## Adicionando colunas com o `mutate()` e `transmute()`\n\nA função `mutate()` adiciona ou transforma uma coluna num conjunto de dados. Por exemplo: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country) %>%\n  mutate(n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 7\n# Groups:   country [18]\n   country  year lgaspcar lincomep  lrpmg lcarpcap `n()`\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl> <int>\n 1 austria  1960     4.17    -6.47 -0.335    -9.77    19\n 2 austria  1961     4.10    -6.43 -0.351    -9.61    19\n 3 austria  1962     4.07    -6.41 -0.380    -9.46    19\n 4 austria  1963     4.06    -6.37 -0.414    -9.34    19\n 5 austria  1964     4.04    -6.32 -0.445    -9.24    19\n 6 austria  1965     4.03    -6.29 -0.497    -9.12    19\n 7 austria  1966     4.05    -6.25 -0.467    -9.02    19\n 8 austria  1967     4.05    -6.23 -0.506    -8.93    19\n 9 austria  1968     4.05    -6.21 -0.522    -8.85    19\n10 austria  1969     4.05    -6.15 -0.559    -8.79    19\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nTambém é possível renomear a variável dentro da função `mutate()`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline %>%\n  group_by(country) %>%\n  mutate(count = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 7\n# Groups:   country [18]\n   country  year lgaspcar lincomep  lrpmg lcarpcap count\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl> <int>\n 1 austria  1960     4.17    -6.47 -0.335    -9.77    19\n 2 austria  1961     4.10    -6.43 -0.351    -9.61    19\n 3 austria  1962     4.07    -6.41 -0.380    -9.46    19\n 4 austria  1963     4.06    -6.37 -0.414    -9.34    19\n 5 austria  1964     4.04    -6.32 -0.445    -9.24    19\n 6 austria  1965     4.03    -6.29 -0.497    -9.12    19\n 7 austria  1966     4.05    -6.25 -0.467    -9.02    19\n 8 austria  1967     4.05    -6.23 -0.506    -8.93    19\n 9 austria  1968     4.05    -6.21 -0.522    -8.85    19\n10 austria  1969     4.05    -6.15 -0.559    -8.79    19\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nAinda, é possível fazer qualquer outra operação: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline |> \n  group_by(country) |> \n  mutate(consumo_renda = lgaspcar / lincomep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 7\n# Groups:   country [18]\n   country  year lgaspcar lincomep  lrpmg lcarpcap consumo_renda\n   <chr>   <int>    <dbl>    <dbl>  <dbl>    <dbl>         <dbl>\n 1 austria  1960     4.17    -6.47 -0.335    -9.77        -0.645\n 2 austria  1961     4.10    -6.43 -0.351    -9.61        -0.638\n 3 austria  1962     4.07    -6.41 -0.380    -9.46        -0.636\n 4 austria  1963     4.06    -6.37 -0.414    -9.34        -0.637\n 5 austria  1964     4.04    -6.32 -0.445    -9.24        -0.639\n 6 austria  1965     4.03    -6.29 -0.497    -9.12        -0.641\n 7 austria  1966     4.05    -6.25 -0.467    -9.02        -0.647\n 8 austria  1967     4.05    -6.23 -0.506    -8.93        -0.650\n 9 austria  1968     4.05    -6.21 -0.522    -8.85        -0.652\n10 austria  1969     4.05    -6.15 -0.559    -8.79        -0.658\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nA função `transmute()` opera da mesma forma que o mutate, mas retorna apenas a variável criada: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngasoline |> \n  group_by(country) |> \n  transmute(consumo_renda = lgaspcar / lincomep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 342 × 2\n# Groups:   country [18]\n   country consumo_renda\n   <chr>           <dbl>\n 1 austria        -0.645\n 2 austria        -0.638\n 3 austria        -0.636\n 4 austria        -0.637\n 5 austria        -0.639\n 6 austria        -0.641\n 7 austria        -0.647\n 8 austria        -0.650\n 9 austria        -0.652\n10 austria        -0.658\n# ℹ 332 more rows\n```\n\n\n:::\n:::\n\n\nExemplo gráfico: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(ggplot2)\n\ngasoline %>% \n  ggplot(aes(x = year, y = lgaspcar, color = country, group = country)) +\n  geom_line() +\n  labs(\n    title = \"Consumo de Gasolina por Carro (log) ao longo do tempo\",\n    x = \"Ano\",\n    y = \"Log do consumo de gasolina por carro\",\n    color = \"País\"\n  ) +\n  theme_classic() +\n  theme(\n    legend.position = \"right\",\n    legend.title = element_text(face = \"bold\"),\n    panel.grid.minor = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](02a-manipulacao-dados_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n\n",
    "supporting": [
      "02a-manipulacao-dados_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}